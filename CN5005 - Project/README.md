# CN5005 – Data Structures and Algorithms

## Ομαδική Εργασία (2025–2026)

### Ομάδα

* Όνομα: Poonam Rani Kaur, θώμας Σιάμος
* ΑΜ: 2879196, 2879220
* Μάθημα: CN5005 - Data Structures and Algorithms
* Διδάσκων Καθηγητής: Νεκτάριος Δελλιγιανάκης
* Γλώσσα: Java

---

### Περιγραφή Εργασίας

Η παρούσα εργασία υλοποιεί βασικές δομές δεδομένων και αλγορίθμους, σε συνδυασμό με επεξεργασία πραγματικού dataset και αναγνώριση συγγενικών σχέσεων. 
Συγκεκριμένα περιλαμβάνει:
- Δυαδίκο Δέντρο Αναζήτησης (BST) με υποστήριξη διπλοτύπων
- AVL Δέντρο με αυτόματη εξισορρόπηση
- Λειτουργία αλλαγής κλειδιού (changeKey)
- Ανάγνωση και επεξεργασία αρχείου persons.csv
- Υπολογισμό συγγενικών σχέσεων
- Command Line Interface (CLI)
- Unit tests με JUnit 5

---

## Δομή 

```
CN5005-Project/
│
├── pom.xml
├── README.md
├── REFLECTION.md
├── Screencast.mp4
├── persons.csv
│
├── src/main/java/edu/cn5005/
│   ├── bst/
│   │   ├── Node.java
│   │   ├── BST.java
│   │   ├── AVL.java
│   │   └── Main.java
│   │
│   ├── cli/
│   │   └── MainCLI.java
│   │
│   ├── persons/
│   │   ├── Person.java
│   │   └── PersonParser.java
│   │
│   └── relations/
│       └── RelationEngine.java
│
└── tests/main/java/edu/cn5005/
    └── edu/cn5005/
        ├── bst/BSTTest.java
        ├── persons/ParserTest.java
        └── relations/RelationTest.java
```

---

## Μέρος Α — Binary Search Tree (BST)

### Node.java

Η κλάση `Node` αναπαριστά έναν κόμβο του δέντρου και περιλαμβάνει τα εξής πεδία:

* **key**: το ακέραιο κλειδί του κόμβου
* **count**: ο αριθμός εμφανίσεων (διπλοτύπων) του ίδιου κλειδιού
* **left**: αναφορά στο αριστερό παιδί (κλειδιά μικρότερα από το `key`)
* **right**: αναφορά στο δεξί παιδί (κλειδιά μεγαλύτερα από το `key`)
* **height**: το ύψος του κόμβου (χρησιμοποιείται από το AVL)

**Χρήση του `count`:**

Το πεδίο `count` χρησιμοποιείται για τη διαχείριση διπλοτύπων.
Όταν εισάγεται ένα κλειδί που υπάρχει ήδη, δεν δημιουργείται νέος κόμβος, απλώς αυξάνεται το `count` κατά 1.
Κατά τη διαγραφή, το `count` μειώνεται κατά 1 και ο κόμβος αφαιρείται πλήρως από το δέντρο μόνο όταν `count = 0`.

---

### BST.java

Η κλάση `BST` υλοποιεί τις βασικές λειτουργίες ενός Binary Search Tree.

#### Εισαγωγή (insert)
Η μέθοδος `insert(int key)` εισάγει το κλειδί σύμφωνα με τους κανόνες του BST.
Αν το κλειδί υπάρχει ήδη στο δέντρο, αυξάνεται το `count` του αντίστοιχου κόμβου χωρίς να δημιουργηθεί νέος κόμβος.

*Μη έγκυρες τιμές εισαγωγής* : 
Στη Java ο τύπος `int` δεν μπορεί να είναι `null` κάθως και οι μη ακέραιες τιμές (π.χ. `String`, `double`) απορρίπτονται κατά τη μεταγλώττιση, επείδη το `key` έχει οριστεί ως `int`.

#### Διαγραφή (delete)
Η μέθοδος `delete(int key)` καλύπτει όλες τις περιπτώσεις διαγραφής:
* κόμβος-φύλλο (αφαιρείση κομβού από το δέντρο),
* κόμβος με ένα παιδί (το παιδί αντικαθιστά τον κόμβο),
* κόμβος με δύο παιδιά (ο κόμβος αντικαθίσταται από inorder successor,το μικρότερο στοιχείο του δεξιού υποδέντρου)

*Η πολιτική που επιλέχθηκε είναι η εξής* :
Όταν `count > 1`, η διαγραφή μειώνει μόνο το `count`.
Ο κόμβος αφαιρείται πλήρως από το δέντρο μόνο όταν το `count` φτάσει στο 0.

#### Διασχίσεις

Υλοποιούνται οι διασχίσεις **preorder**, **inorder** και **postorder**, οι οποίες επιστρέφουν στοιχεία της μορφής
`key:count` με τη βοήθεια των αναδρομικών μεθοδών **preorderRec**, **inorderRec** και **postorderRec**. Η `inorder` διασχίζει το δέντρο σε αύξουσα σειρά κλειδιών.

---

### Main.java

Το αρχείο `Main.java` επιδεικνύει τη λειτουργικότητα του BST και περιλαμβάνει:

* δημιουργία κλειδιών από τους ΑΜ των μελών της ομάδας,
* εισαγωγή των κλειδιών στο δέντρο,
* εμφάνιση των τριών διασχίσεων,
* παραδείγματα διαγραφής υπαρκτών και μη υπαρκτών κλειδιών.

---

## Μέρος Β — AVL Tree

### AVL.java

Η κλάση `AVL` επεκτείνει τη `BST` και προσθέτει μηχανισμό αυτόματης εξισορρόπησης, ώστε το δέντρο να παραμένει
ισορροπημένο μετά από κάθε εισαγωγή ή διαγραφή.

#### Εξισορρόπηση (Balancing)

Μετά από κάθε τροποποίηση υπολογίζεται ο **balance factor** κάθε κόμβου ως:

```
height(left) − height(right)
```

Όταν η απόλυτη τιμή του balance factor υπερβαίνει το 1, εφαρμόζονται οι κατάλληλες περιστροφές:

* **LL**: εισαγωγή στο αριστερό παιδί του αριστερού υποδέντρου
* **RR**: εισαγωγή στο δεξί παιδί του δεξιού υποδέντρου
* **LR**: εισαγωγή στο δεξί παιδί του αριστερού υποδέντρου -> αριστερή και στη συνέχεια δεξιά περιστροφή
* **RL**: εισαγωγή στο αριστερό παιδί του δεξιού υποδέντρου -> δεξιά και στη συνέχεια αριστερή περιστροφή

#### Παράδειγμα

Εισαγωγή **9220, 9196, 6789** προκαλεί περίπτωση **LL** η οποία πρέπει να έχει μία **δεξιά περιστροφή**, με ρίζα το **9196** και παιδιά τα **6789** και **9220**.

---

#### Αλλαγή Κλειδιού (`changeKey`)

Η μέθοδος `changeKey(int oldKey, int newKey)` αντικαθιστά όλες τις εμφανίσεις του `oldKey` με το `newKey`, διατηρώντας
το αρχικό `count`.

Η διαδικασία που ακολουθείται είναι:
1. Εντοπισμός του κόμβου με `oldKey`,
2. Αποθήκευση του `count`,
3. Πλήρης διαγραφή του `oldKey`,
4. Εισαγωγή του `newKey` τον ίδιο αριθμό φορών.

Η μέθοδος επιστρέφει `true` αν η αλλαγή πραγματοποιηθεί επιτυχώς και `false` αν το `oldKey` δεν υπάρχει στο δέντρο.

---

## Μέρος C — `persons.csv`: Ανάγνωση

Το αρχείο **`persons.csv`** αποτελεί τη κεντρική βάση για το γενεαλογικό δέντρο και χρησιμοποιείται σε όλα τα επόμενα στάδια επεξεργασίας σχέσεων.

**Επιλογή CSV :**
Επιλέξαμε τη Επιλογή Α, δήλαδη το αρχείο από τον καθηγητή, το οποίο περιλαμβάνει:
* τουλάχιστον **25 άτομα**
* **3 γενιές**
* συνεκτικές οικογενειακές σχέσεις (γονείς – σύζυγοι)
---

### Μορφή Αρχείου (`persons.csv`)

Το αρχείο είναι σε **UTF-8**, με **header** και **κόμμα (`,`)** ως διαχωριστικό.
Η πρώτη γραμμή είναι:

```
id,name,gender,father_id,mother_id,spouse_id
```

* `id`: μοναδικός ακέραιος αναγνωριστικός
* `name`: πλήρες όνομα
* `gender`: Male / Female / Unknown
* `father_id`, `mother_id`, `spouse_id`: αναφορές σε `id` (κενό αν άγνωστο)

Το αρχείο παραδίδεται **αποκλειστικά σε μορφή CSV** με όνομα `persons.csv`.

---

### `Person.java`

Η κλάση `Person` αναπαριστά ένα άτομο του αρχείου και περιλαμβάνει τα πεδία:
`id`, `name`, `gender`, `fatherId`, `motherId`, `spouseId`.
Τα πεδία γονέων και συζύγου αποθηκεύονται ως `Integer` και μπορούν να είναι `null`.

---

### `PersonParser.java`

Ο parser:
1. Διαβάζει το `persons.csv`
2. Δημιουργεί αντικείμενα `Person` για κάθε γραμμή
3. Αποθηκεύει τα δεδομένα σε δύο ευρετήρια:
   * `Map<Integer, Person>` (id → Person)
   * `Map<String, Integer>` (name → id)
4. Εκτυπώνει όλα τα ονόματα που φορτώθηκαν, για επιβεβαίωση επιτυχούς parse

Υπάρχει έλεγχος σφαλμάτων για: κενές γραμμές, λανθασμένες εγγραφές, κενά πεδία (αποθηκεύονται ως `null`)

---

### `ParserTest.java`

Στην κλάση αυτή υλοποιήθηκαν unit tests με **JUnit**, τα οποία ελέγχουν:

* ότι φορτώνονται σωστά **25 εγγραφές**
* ότι συγκεκριμένα `id` αντιστοιχούν στα αναμενόμενα ονόματα
* ότι οι γονικές και συζυγικές σχέσεις αποθηκεύονται σωστά
* ότι κενά πεδία (`father_id`, `mother_id`, `spouse_id`) αποθηκεύονται ως `null`

Τα tests εκτελούνται με:

```
mvn test
```

---

## Μέρος Δ — Ανίχνευση Συγγενειών
Μετά τη φόρτωση του `persons.csv`, υλοποιήθηκε η κλάση **RelationEngine.java**, η οποία παρέχει μεθόδους ελέγχου
οικογενειακών σχέσεων μεταξύ ατόμων, βασισμένες στα `id` και στα αποθηκευμένα δεδομένα γονέων, παιδίων, παπούδες/γιαγίαδες, συζύγων. Όλες οι
μέθοδοι επιστρέφουν `boolean` και διαχειρίζονται άγνωστα ids.
---

### Πατέρας / Μητέρα

Υλοποιήθηκαν οι μέθοδοι:

* `isFather(idA, idB)`
* `isMother(idA, idB)`

Ελέγχουν αν το άτομο `idA` είναι πατέρας ή μητέρα του `idB`, με έλεγχο φύλου και σωστή διαχείριση άγνωστων ids.

---

### Παιδί / Αδέλφια

Υλοποιήθηκαν:

* `isChild(idA, idB)` 
* `isSibling(idA, idB)`

Δύο άτομα θεωρούνται αδέλφια αν μοιράζονται **τουλάχιστον έναν κοινό γονέα**. Η περίπτωση `idA == idB` απορρίπτεται.

---

### Παππούς / Γιαγιά και Εγγόνια

Υλοποιήθηκαν:

* `isGrandparent(idA, idB)`
* `isGrandchild(idA, idB)`

Η λογική βασίζεται στους γονείς του Β και στους γονείς αυτών (2 επίπεδα βάθους).

---

### Πρώτα Ξαδέρφια

Η μέθοδος `isFirstCousin(idA, idB)` επιστρέφει `true` αν τα δύο άτομα μοιράζονται τουλάχιστον **έναν** κοινό παππού/γιαγιά, χωρίς να είναι αδέλφια ή το ίδιο άτομο.

---

### Συνάρτηση `relation(nameA, nameB)` και CLI

Υλοποιήθηκε η μέθοδος `relation(nameA, nameB)` η οποία:

1. Μετατρέπει ονόματα σε ids μέσω ευρετηρίου
2. Ελέγχει διαδοχικά όλες τις βασικές σχέσεις
3. Επιστρέφει την **πρώτη σχέση που εντοπίζεται**
4. Διαχειρίζεται άγνωστα ονόματα και ίδιες ταυτότητες

CLI (MainCLI)

Η κλάση `MainCLI` παρέχει διεπαφή γραμμής εντολών για τις βασικές λειτουργίες:

1. `insert <id> <name> <gender>` : εισαγωγή ατόμου
2. `delete <id>` : διαγραφή ατόμου
3. `changeKey <oldId> to <newId>` : αλλαγή ID
4. `relation "Name1" "Name2"` : εύρεση σχέσης μεταξύ δύο ατόμων

Οι εντολές insert, delete και changeKey παρέχονται για λόγους επίδειξης (demonstrational) και δεν αποθηκεύουν μόνιμα αλλαγές στο αρχείο persons.csv.


---

## Μέρος Ε — Σύνθετες Σχέσεις

Υλοποιήθηκαν οι εξής επιπλέον σχέσεις και ενσωματώθηκαν στη `relation`:

* **Half-siblings** (`isHalfSibling`): κοινός μόνο ένας γονέας
* **Spouse check** (`isSpouse`): έλεγχος μέσω του `spouse_id`

Οι παραδοχές και σχεδιαστικές επιλογές (π.χ. απουσία πολλαπλών γάμων, κενά γονεϊκά πεδία) τεκμηριώνονται στο **`REFLECTION.md`**.

---

## Μέρος F — Unit Tests, Screencast και Viva

### Build Configuration (pom.xml)

Στο έργο χρησιμοποιηθηκε Maven για compilation, testing και δημιουργία εκτελέσιμου JAR.

Στο αρχείο **pom.xml** έχουν οριστεί:

- Java 23 ως γλώσσα μεταγλώττισης
- JUnit 5 για unit tests
- Surefire plugin για εκτέλεση των tests με mvn test
- Shade plugin για δημιουργία runnable JAR με ενσωματωμένο Main-Class

Η χρήση του Shade plugin είναι απαραίτητη ώστε να μπορεί να εκτελεστεί η εφαρμογή με:

```
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar ...
```


### Unit Tests

Όλα τα unit tests βρίσκονται στο φάκελο `tests` και υλοποιήθηκαν με **JUnit 5**.
Τα tests τρέχουν με **μία εντολή** μέσω Maven και ολοκληρώνονται χωρίς χειροκίνητη παρέμβαση.

---

### 1. Clean & Build (Maven)

Για καθαρισμό προηγούμενων builds και δημιουργία του εκτελέσιμου JAR:

```bash
mvn clean package
```

Αυτό θα δημιουργήσει:

```
target/cn5005-coursework-1.0-SNAPSHOT.jar
```

---

### 2. Εκτέλεση όλων των tests

Με μία εντολή:

```bash
mvn test
```
---

### 3. CLI σε Java (MainCLI)

Το CLI φορτώνει το `persons.csv` και εκτελεί queries:
```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar relation "Ιωάννης Καποδίστριας" "Χριστίνα Καποδίστρια"
```
Το πρόγραμμα εμφανίζει σαφές μήνυμα αποτελέσματος ή σφάλματος.

---

### 4. Insert a node

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar insert 31 "Κωνσταντίνος Αργυρός" Male 3 7
```
---

### 5. Delete a node

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar delete 31
```
---

### 6. Change key

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar changeKey 30 35
```

---

### 7. Traversals

```bash
 java -cp target/classes edu.cn5005.bst.Main
```

---

### 8. Relation queries

#### Direct relation

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar relation "Ιωάννης Καποδίστριας" "Αλέξανδρος Καποδίστριας"
```
---

#### Cousin's relation

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar relation "Αλέξανδρος Καποδίστριας" "Μαρία Καποδίστρια"
```
---

#### No relation

```bash
java -jar target/cn5005-coursework-1.0-SNAPSHOT.jar relation "Ιωάννης Καποδίστριας" "Νίκη Μάνου"
```
---

### Λειτουργίες των unit tests

1. **BST & AVL (`BSTTest.java`)**
    * Εισαγωγή κόμβων και διαχείριση διπλοτύπων με `count`
    * Διαγραφή κόμβων (μείωση `count` ή πλήρης αφαίρεση)
    * Διασχίσεις: preorder, inorder, postorder
    * Έλεγχος ισορροπίας AVL
    * Έλεγχος `changeKey` με διατήρηση του αρχικού count

* **Φόρτωση δεδομένων (`ParserTest.java`)**
    * Ορθή φόρτωση όλων των εγγραφών από το `persons.csv`
    * Σωστή αντιστοίχιση name -> id, id -> Person
    * Έλεγχος γονεϊκών σχέσεων
    * Έλεγχος πεδίου συζύγου (`spouseId`)


* **Σχέσεις (`RelationTest.java`)**
    * Έλεγχος σχέσεων γονέα, παιδιού, αδελφών
    * Έλεγχος πρώτων ξαδέρφων
    * Έλεγχος περιπτώσεων όπου τα άτομα δεν σχετίζονται

---

### Screencast

Δημιουργήθηκε screencast διάρκειας **2 λεπτών**, στο οποίο παρουσιάζονται συνοπτικά:

* mvn clean package
* mvn test 
* Φόρτωση του `persons.csv`
* Εισαγωγή και διαγραφή κόμβων σε BST/AVL
* Τρεις κλήσεις της `relation`:
    * μία άμεση οικογενειακή σχέση
    * μία σχέση πρώτων ξαδέρφων
    * μία περίπτωση όπου τα άτομα δεν σχετίζονται
* Οι τρεις βασικές διασχίσεις (preorder, inorder, postorder)

---

## Συνεισφορά Μελών Ομάδας

* **Μέρος A (BST):** Poonam Rani Kaur
* **Μέρος Β (AVL, changeKey):** Poonam Rani Kaur
* **Μέρος C (persons.csv, Parser):** Θώμας Σιάμος
* **Μέρος D (D.1–D.4 σχέσεις):** Θώμας Σιάμος
* **Μέρος D.5 (relation, CLI):** Θώμας Σιάμος, Poonam Rani Kaur
* **Μέρος E (σύνθετες σχέσεις):** Poonam Rani Kaur, Θώμας Σιάμος
* **Μέρος F (Unit Tests):** Poonam Rani Kaur, Θώμας Σιάμος



